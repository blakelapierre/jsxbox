<html>
  <head>
    <title>mathbox/jsx</title>
  </head>
  <body>
    <script src="handler.js"></script>
    <script src="mathbox-bundle.js"></script>

    <script type="mathbox/jsx">
      const fftSize = Math.pow(2, 10),
            pointSize = 4;

      const speechCapacity = 5;

      <root focus={3}>
        <camera proxy={true} position={[0, 0, 10]} />

        <polar
          position={[0, 3, 0]}
          range={[[-fftSize / 2, fftSize / 2], [0, 255]]}
          scale={[8 * 16 / 9, 3]}
        >
          <array
            id="intTime"data={[]}
            length={fftSize}
            channels={1}
          />
          <swizzle
            order={"yx"}
          />
          <spread
            width={[fftSize, 0, 0, 0]}
          />
          <point
            size={pointSize}
            color="#FF0000"
          />

          <array
            id="intFreq"
            data={[]}
            length={fftSize / 2}
            channels={1}
          />
          <swizzle
            order="yx"
          />
          <spread
            width={[fftSize, 0, 0, 0]}
          />
          <point
            size={pointSize + pointSize}
            color="#0000FF"
            blending={'add'}
            opacity={0.9}
          />
        </polar>

        <cartesian
          position={[0, 0, 0]}
          range={[[-fftSize / 2, fftSize / 2], [-1, 1]]}
          scale={[8 * 16 / 9, 1]}
        >
          <array
            id="audioTime"
            data={[]}
            length={fftSize}
            channels={1}
            history={3}
          />
          <swizzle order="yx" />
          <spread width={[fftSize, 0, 0, 0]} />
          <point
            size={pointSize}
            color="#FF0000"
            blending={'add'}
            opacity={0.5}
          />
        </cartesian>

        <cartesian
          position={[0, 0, 0]}
          range={[[-fftSize / 2, fftSize / 2], [-196, 0]]}
          scale={[16 * 16 / 9, 1]}
        >
          <interval length={speechCapacity} />
          <text
            width={speechCapacity}
            expr={(emit, x) => emit(getSpeech(x))}
          />
          <swizzle order="yx" />
          <spread width={[1, 0, 0, 0]} />
          <label
            size={24 * 2}
            outline={0}
            color="#22DD22"
          />
        </cartesian>

        <cartesian
          position={[0, -3, 0]}
          range={[[-fftSize / 2, fftSize / 2], [-196, 0], [1, 3]]}
          scale={[8 * 16 / 9, 3]}
        >
          <array
            id="audioFreq"
            data={[]}
            length={fftSize / 2}
            channels={1}
            history={3}
          />
          <transpose
            order="xwyz"
          />
          <swizzle order={"yxwz"} />
          <spread width={[fftSize, 0, 0, 0]} depth={[3, 0, 0, 0]} />
          <point size={pointSize} color="#0000FF" blending={'add'} opacity={0.8} />
        </cartesian>
      </root>

      const context = new (window.AudioContext || window.webkitAudioContext)();

      navigator.getUserMedia = navigator.getUserMedia
                            || navigator.webkitGetUserMedia
                            || navigator.mozGetUserMedia
                            || navigator.msGetUserMedia;

      navigator.getUserMedia({audio: true}, stream, error);

      recognizeSpeech(window.webkitSpeechRecognition);

      function stream(stream) {
        const input = context.createMediaStreamSource(stream),
              analyser = context.createAnalyser();

        input.connect(analyser);

        setAnalyser(analyser);
      }

      function error(error) {
        console.log(error);
      }

      function setAnalyser(analyser) {
        console.dir(analyser);
        analyser.fftSize = fftSize;

        const floatTime = new Float32Array(analyser.fftSize),
              floatFreq = new Float32Array(analyser.frequencyBinCount),
              intTime = new Uint8Array(analyser.fftSize),
              intFreq = new Uint8Array(analyser.frequencyBinCount);

        three.on('update', () => {
          analyser.getFloatTimeDomainData(floatTime);
          analyser.getFloatFrequencyData(floatFreq);

          analyser.getByteTimeDomainData(intTime);
          analyser.getByteFrequencyData(intFreq);

          const timePower = power(intTime),
                freqPower = power(intFreq);
        });

        mathbox.select('#audioTime').set('data', floatTime);
        mathbox.select('#audioFreq').set('data', floatFreq);

        mathbox.select('#intTime').set('data', intTime);
        mathbox.select('#intFreq').set('data', intFreq);

        function power(array) {
          const {length} = array;

          let sum = 0;

          for (let i = 0; i < length; i++) sum += array[i] * array[i];

          return sum / length;
        }
      }

      let speech = [],
          nextIndex = 0;
      function recognizeSpeech(SpeechRecognition) {
        const sr = new SpeechRecognition();

        sr.continuous = true;
        sr.intermResults = true;
        sr.lang = 'en-US';

        console.log(sr);

        sr.onstart = () => console.log('start');
        sr.onresult = gotResult;
        sr.onerror = event => console.log('error', event);
        sr.onend = () => console.log('end') & sr.start();

        sr.onspeechstart = event => console.log('speech start', event);
        sr.onspeechend = event => console.log('speech end', event);

        sr.onsoundstart = event => console.log('sound start', event);
        sr.onsoundend = event => console.log('sound end', event);

        sr.start();

        function gotResult(event) {
          const {results, resultIndex, timeStamp} = event,
                {length} = results;

          if (results) {
            const r = new Date(timeStamp).toString() + printResult(results[resultIndex]);
            // const r = map(results, printResult);

            let alt = speech[nextIndex] = r;
            nextIndex = (nextIndex + 1) % speechCapacity;
          }

          console.log(event);

          function printResult(result) {
            const {length} = result;

            console.log(result);

            return result.isFinal ? map(result, formatAlternative) : [];

            function formatAlternative(alternative) {
              const {confidence, transcript} = alternative;

              return `${confidence} ${transcript}`;
            }
          }
        }
      }

      function getSpeech(x) {
        return speech[x] || `speech ${x}`;
      }

      function map(arraylike, fn) {
        return Array.prototype.map.call(arraylike, fn);
      }

    </script>
  </body>
</html>
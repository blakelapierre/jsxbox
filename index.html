<html>
  <head>
    <title>mathbox/jsx</title>
  </head>
  <body>
    <script src="handler.js"></script>
    <script src="mathbox-bundle.js"></script>

    <script type="mathbox/jsx">
      const fftSize = Math.pow(2, 6),
            pointSize = 1;

      const speechCapacity = 5;


      const settings = {
        int: {
          time: {
            fftSize,
            history: 480,
            spread: 2,
            size: 1,
            shape: 'square',
            color: '#993333'
          },

          freq: {
            fftSize,
            history: 480,
            spread: 1,
            size: 1,
            shape: 'square',
            // color: '#0000FF',
            color: t => freqPower,
            opacity: 0.85
          }
        },

        float: {
          freq: {
            fftSize,
            history: 480,
            spread: 1,
            shape: 'circle',
            color: '#FFFFFF',
            opacity: 0.66,
            size: 1
          }
        }
      };

      <root focus={3}>
        <camera proxy={true}
                position={[-3, 0.1, 0]} />
        <polar
          position={[0, 3, 0]}
          range={[[-settings.int.time.fftSize / 2, settings.int.time.fftSize / 2], [0, settings.int.time.fftSize]]}
          scale={[16 / 9, 1]}
        >
          <array
            length={settings.int.time.fftSize}
            channels={1}
            history={settings.int.time.history}
            expr={(emit, x, i, time) => emit(intTime[x])}
          />
          <transpose order='xw' />
          <swizzle
            order={"yx"}
          />
          <spread
            width={[settings.int.time.fftSize, 0, 0, 0]}
            depth={[0, 0, settings.int.time.spread, 0]}
          />
          <point
            size={settings.int.time.size}
            shape={settings.int.time.shape}
            color={settings.int.time.color}
          />
        </polar>


        <polar
          position={[0, 0.25, 0]}
          range={[[-settings.int.time.fftSize / 2, settings.int.time.fftSize / 2], [0, 1024]]}
          scale={[16 / 9, 1]}
        >
          <array
            length={settings.int.freq.fftSize / 2}
            channels={1}
            history={settings.int.freq.history}
            expr={(emit, x, i, time) => emit(intFreq[x])}
          />
          <transpose order="xw" />
          <swizzle order='yx' />
          <spread
            width={[settings.int.freq.fftSize, 0, 0, 0]}
            depth={[0, 0, settings.int.freq.spread, 0]}
          />
          <point
            size={settings.int.freq.size}
            color={settings.int.freq.color}
            opacity={settings.int.freq.opacity}
            blending={'add'}
          />
        </polar>

        <cartesian
          position={[0, 0, 0]}
          range={[[-fftSize / 2, fftSize / 2], [-1, 1]]}
          scale={[16 / 9, 1]}
        >
          <array
            length={fftSize}
            channels={1}
            history={120}
            expr={(emit, x, i, time) => emit(floatTime[x])}
          />
          <transpose order="xw"/>
          <swizzle order="yx" />
          <spread width={[fftSize, 0, 0, 0]} depth={[0, 0, 1, 0]} />
          <point
            size={pointSize}
            color="#FF0000"
            blending={'add'}
            opacity={1}
          />
        </cartesian>

        <cartesian
          position={[0, 0, 1]}
          range={[[-settings.float.freq.fftSize / 2, 0], [-196, 0], [0, 1]]}
          scale={[16 / 9, 1]}
        >
          <array
            length={settings.float.freq.fftSize / 2}
            channels={1}
            expr={(emit, x, i, time) => emit(floatFreq[x])}
            history={settings.float.freq.history}
          />
          <transpose order="xw" />
          <swizzle order={"yx"} />
          <spread width={[settings.float.freq.fftSize, 0, 0, 0]} depth={[0, 0, settings.float.freq.spread, 0]} />
          <point size={settings.float.freq.size} color={settings.float.freq.color} blending={'normal'} opacity={settings.float.freq.opacity} shape={settings.float.freq.shape} />
        </cartesian>

      </root>

      let floatTime, floatFreq, intTime, intFreq, timePower, freqPower;

      const context = new (window.AudioContext || window.webkitAudioContext)();

      navigator.getUserMedia = navigator.getUserMedia
                            || navigator.webkitGetUserMedia
                            || navigator.mozGetUserMedia
                            || navigator.msGetUserMedia;

      navigator.getUserMedia({audio: true}, stream, error);

      recognizeSpeech(window.webkitSpeechRecognition);

      function stream(stream) {
        const input = context.createMediaStreamSource(stream),
              analyser = context.createAnalyser();

        input.connect(analyser);

        setAnalyser(analyser);
      }

      function error(error) {
        console.log(error);
      }

      function setAnalyser(analyser) {
        console.dir(analyser);
        analyser.fftSize = fftSize;

        floatTime = new Float32Array(analyser.fftSize);
        floatFreq = new Float32Array(analyser.frequencyBinCount);
        intTime = new Uint8Array(analyser.fftSize);
        intFreq = new Uint8Array(analyser.frequencyBinCount);

        three.on('update', () => {
          analyser.getFloatTimeDomainData(floatTime);
          analyser.getFloatFrequencyData(floatFreq);

          analyser.getByteTimeDomainData(intTime);
          analyser.getByteFrequencyData(intFreq);

          timePower = power(intTime);
          freqPower = power(intFreq);
        });


        function power(array) {
          const {length} = array;

          let sum = 0;

          for (let i = 0; i < length; i++) sum += array[i] * array[i];

          return sum / length;
        }
      }

      let speech = [],
          nextIndex = 0;
      function recognizeSpeech(SpeechRecognition) {
        const sr = new SpeechRecognition();

        sr.continuous = true;
        sr.intermResults = true;
        sr.lang = 'en-US';

        console.log(sr);

        sr.onstart = () => console.log('start');
        sr.onresult = gotResult;
        sr.onerror = event => console.log('error', event);
        sr.onend = () => console.log('end') & sr.start();

        sr.onspeechstart = event => console.log('speech start', event);
        sr.onspeechend = event => console.log('speech end', event);

        sr.onsoundstart = event => console.log('sound start', event);
        sr.onsoundend = event => console.log('sound end', event);

        sr.start();

        function gotResult(event) {
          const {results, resultIndex, timeStamp} = event,
                {length} = results;

          if (results) {
            const r = new Date(timeStamp).toString() + printResult(results[resultIndex]);
            // const r = map(results, printResult);

            let alt = speech[nextIndex] = r;
            nextIndex = (nextIndex + 1) % speechCapacity;
          }

          console.log(event);

          function printResult(result) {
            const {length} = result;

            console.log(result);

            return result.isFinal ? map(result, formatAlternative) : [];

            function formatAlternative(alternative) {
              const {confidence, transcript} = alternative;

              return `${confidence} ${transcript}`;
            }
          }
        }
      }

      function getSpeech(x) {
        return speech[x] || `speech ${x}`;
      }

      function map(arraylike, fn) {
        return Array.prototype.map.call(arraylike, fn);
      }

    </script>
  </body>
</html>
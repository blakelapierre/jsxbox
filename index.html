<html>
  <head>
    <title>mathbox/jsx</title>

    <style>
    body {
      margin: 0;
      padding: 0;

      display: flex;

      overflow: hidden;
    }
    </style>
  </head>
  <body>
    <script src="handler.js"></script>
    <script src="mathbox-bundle.js"></script>

    <script>
      function expandPanel(event, settings) {
        var box = settings.parentElement,
            panel = box.getElementsByClassName('panel')[0],
            canvas = box.getElementsByTagName('canvas')[0];

        if (box.classList.contains('settings')) box.classList.remove('settings');
        else box.classList.add('settings');

        canvas.style.width = '100%';
      }
    </script>

    <div class="box">
      <style>
      .box {
        position: relative;

        display: flex;

        flex: 1;
      }

      .box mathbox {
        flex: 1;
      }

      .box .settings {
        position: absolute;
        top: 0;
        right: 0;

        color: #fff;

        cursor: pointer;

        user-select: none;
      }
      </style>
      <mathbox tabindex="1">
        <script type="mathbox/jsx">
          <root>
            <cartesian range={[[-1, 1], [-1, 1], [-1, 1]]} scale={[1, 1, 1]}>
              <present index={1}>
                <slide>
                  <reveal duration={2}>
                    <transform position={[0, 1, 0]} scale={[11/10, 11/10, 11/10]}>
                      <step script={[[{position: [0, 1, 0]}], [{position: [0, 3/4, 0]}], [{position: [0, 1/2, 0]}], [{position: [0, 1/4, 0]}], [{position: [0, 0, 0]}], [{position: [0, -1/4, 0]}], [{position: [0, -1/2, 0]}], [{position: [0, -3/4, 0]}], [{position: [0, -1, 0]}]]} />
                      <grid axes={[1, 3]} width={2} color={11579568} depth={1/2} />
                    </transform>
                  </reveal>
                  <slide>
                    <reveal stagger={[1, 1, 0, 0]}>
                      <transform position={[0, 3/4, 0]}>
                        <grid axes={[1, 3]} width={2} color={3145616} depth={1/2} />
                      </transform>
                    </reveal>
                  </slide>
                  <slide>
                    <reveal>
                      <move from={[1, 0, 0, 0]}>
                        <transform position={[0, 1/2, 0]}>
                          <grid axes={[1, 3]} width={2} color={3121136} depth={1/2} />
                        </transform>
                      </move>
                      <slide>
                        <reveal stagger={1}>
                          <move stagger={1} to={[0, -1, 0, 0]}>
                            <transform position={[0, 1/4, 0]}>
                              <grid detailX={20} detailY={20} axes={[1, 3]} width={2} color={3121136} depth={1/2} />
                            </transform>
                          </move>
                        </reveal>
                      </slide>
                    </reveal>
                  </slide>
                </slide>
                <slide>
                  <grid axes={[1, 3]} width={2} color={16732048} depth={1/2} />
                  <reveal stagger={[1]} duration={1}>
                    <interval length={128} expr={(emit, x, i, t) => {
                        if (i == 0) console.log('emitting')
                        emit(x, .5 + .5 * Math.sin((x + t) * 3));
                      }} channels={2} />
                    <line color={3182847} width={20} />
                  </reveal>
                </slide>
                <slide>
                  <reveal>
                    <transform position={[0, -1/4, 0]}>
                      <grid axes={[1, 3]} width={2} color={16723856} depth={1/2} />
                    </transform>
                  </reveal>
                  <slide>
                    <reveal>
                      <move stagger={2} from={[0, -2, 0, 0]} to={[0, -2, 0, 0]}>
                        <transform position={[0, -1/2, 0]}>
                          <grid detailX={20} detailY={20} axes={[1, 3]} width={2} color={10432496} depth={1/2} crossed={true} />
                        </transform>
                      </move>
                    </reveal>
                  </slide>
                  <slide early={1} late={1}>
                    <reveal>
                      <transform position={[0, -3/4, 0]}>
                        <grid axes={[1, 3]} width={2} color={10432496} depth={1/2} />
                      </transform>
                    </reveal>
                  </slide>
                  <slide>
                    <reveal>
                      <transform position={[0, -1, 0]}>
                        <grid axes={[1, 3]} width={2} color={10432496} depth={1/2} />
                      </transform>
                    </reveal>
                  </slide>
                </slide>
              </present>
              <camera lookAt={[0, 0, 0]} position={t => [-3 * Math.cos(t), .4 + .2 * Math.cos(t * .381), -3 * Math.sin(t)]} />
            </cartesian>
          </root>

          // set({
          //   controls: [
          //     [37, 38], 'prevSlide',
          //     [39, 40], 'nextSlide'
          //   ],
          //   commands: {
          //     'prevSlide': {'present': {index: ['length', (index, length) => (length + index - 1) % length]}},
          //     'nextSlide': {'present': {index: ['length', (index, length) => (index + 1) % length]}}
          //   }
          // })

          window.onMathBoxViewBuilt = view => set(view, [
              [ [8], 'reverseLookAt'],
              [ [32], 'lookAt'],
              [ [37, 38], 'prevSlide' ],
              [ [39, 40], 'nextSlide' ]
            ], {
              'reverseLookAt': {'camera': {lookAt: lookAt => lookAt.addScalar(-0.5)}},
              'lookAt': {'camera': {lookAt: lookAt => lookAt.addScalar(0.5)}},
              'prevSlide': {'present': {index: ['length', (index, length) => (length + index - 1) % length]}},
              'nextSlide': {'present': {index: ['length', (index, length) => (index + 1) % length]}}
          }) & view._context.canvas.parentElement.focus();

          function set(view, controls, commands) {
            const actionHandler = generateActionHandler(controls, define(commands));

            view._context.canvas.parentElement.addEventListener('mousedown', event => view._context.canvas.parentElement.focus());
            window.addEventListener('keydown', event => event.target === view._context.canvas.parentElement ? actionHandler(event.keyCode) : console.log(event));

            function generateActionHandler(controls, commands) {
              const actions = controls.reduce((actions, [keys, command]) => {
                  keys.forEach(key => actions[key] = command);
                  return actions;
                }, {});

              return keyCode => run(commands[actions[keyCode]]);
            }

            function run(command) {
              for (let name in command) {
                const props = command[name],
                      element = view.select(name);

                for (let propName in props) {
                  const action = props[propName],
                        propValue = element.get(propName);

                  if (typeof action === 'function') element.set(propName, action(propValue));
                  else {
                    const parameters = [];
                    let i = 0;
                    for (; i < action.length - 1; i++) parameters.push(element.get(action[i]));
                    element.set(propName, action[i](propValue, ...parameters));
                  }
                }
              }
            }

            function define(commands) {
              //may want to do something fancier here, perhaps there are things in `run` that could be pre-cached?
              return commands;
            }
          }
          // applyControls(controls);

          // function applyControls(controls) {
          //   window.onkeydown = event => {

          //   }
          // }

          // window.onkeydown = event => {
          //   const present = view.select('present'),
          //         index = present.get('index'),
          //         length = present.get('length');

          //   switch (event.keyCode) {
          //     case 37:
          //     case 38: commands['prevSlide'](); break;
          //     case 39:
          //     case 40: commands['nextSlide'](); break;
          //   }
          // }

          //   index: ['length', (index, length) => (length + index - 1) % length]

          // nextSlide: {
          //   index: ({length, index}) => (length + index - 1) % length
          // }
          // prevSlide: {
          //   index: ({length, index}) => (index + 1) % length;
          // }

          // present.set(name, fn(present))

          // function nextSlide(present) {
          //   present.set()
          // }
        </script>
      </mathbox>
      <div class="panel">
        <style>
          .box .panel {
            display: none;
            flex: 1;
          }

          .box.settings .panel {
            display: block;
          }
        </style>
      </div>
      <div class="settings" onclick="expandPanel(event, this)">S</div>
    </div>

    <div class="box">
      <style>
      .box {
        position: relative;

        display: flex;

        flex: 1;
      }

      .box mathbox {
        flex: 1;
      }

      .box .settings {
        position: absolute;
        top: 0;
        right: 0;

        color: #fff;

        cursor: pointer;

        user-select: none;
      }
      </style>
      <mathbox tabindex="2">
        <script type="mathbox/jsx">
          const position = [0, 0, -5, 0],
                velocity = [0, 0, 0, 0];

          function cameraPosition(t, dt) {
            const [x, y, z, w] = position,
                  [vx, vy, vz, vw] = velocity;

            velocity[0] = vx - decay(vx, dt);
            velocity[1] = vy - decay(vy, dt);
            velocity[2] = vz - decay(vz, dt);
            velocity[3] = vw - decay(vw, dt);

            position[0] = x + vx * dt;
            position[1] = y + vy * dt;
            position[2] = z + vz * dt;
            position[3] = w + vw * dt;

            return position;
          }

          function decay(value, dt) {
            return value * dt;
          }

          <root>
              <camera
                lookAt={[Math.sqrt(Math.PI), 0, 0]}
                position={cameraPosition} />
              <matrix width={256} height={256} channels={2} expr={(emit, x, y) => (x !== 0 && y !== 0 && x % y === 0) ? emit(x, y) : undefined} />
              <swizzle order={'xyyx'} />
              <cartesian range={[[1, 256], [1, 256], [-1, 1]]} scale={[16/9, 1, 1]} position={[Math.sqrt(Math.PI), 0, 0]} />
              <point size={5} color={[64 / 255, 128 / 255, 192 / 255]} blending={'add'}/>
          </root>

          // set({
          //   controls: [
          //     [37, 38], 'prevSlide',
          //     [39, 40], 'nextSlide'
          //   ],
          //   commands: {
          //     'prevSlide': {'present': {index: ['length', (index, length) => (length + index - 1) % length]}},
          //     'nextSlide': {'present': {index: ['length', (index, length) => (index + 1) % length]}}
          //   }
          // })

          let modifier = identity;
          window.onMathBoxViewBuilt = view => set(view, [
              [ [16, 32],  'turbo' ],
              [ 65,  'left' ],
              [ 68,  'right' ],
              [ 81,  'up'],
              [ 83,  'backward' ],
              [ 87,  'forward' ],
              [ 90,  'down' ]
            ], {
              'turbo': view => modifier = modifier === identity ? turbo : identity,
              'left': view => velocity[0] = modifier(-5),
              'right': view => velocity[0] = modifier(5),
              'up': view => velocity[1] = modifier(5),
              'down': view => velocity[1] = modifier(-5),
              'backward': view => velocity[2] = modifier(-5),
              'forward': view => velocity[2] = modifier(5)
          }) & view._context.canvas.parentElement.focus();

          function identity(value) { return value; }
          function turbo(value) { return value * value * value / Math.abs(value); }

          function set(view, controls, commands) {
            const actionHandler = generateActionHandler(controls, define(commands));

            view._context.canvas.parentElement.addEventListener('mousedown', event => view._context.canvas.parentElement.focus());
            window.addEventListener('keydown', event => event.target === view._context.canvas.parentElement ? actionHandler(event.keyCode) : console.log(event, view));

            function generateActionHandler(controls, commands) {
              const actions = controls.reduce((actions, [keys, command]) => {
                  (typeof keys === 'number' ? [keys] : keys).forEach(key => actions[key] = command);
                  return actions;
                }, {});

              return keyCode => run(commands[actions[keyCode]]);
            }

            function run(command) {
              if (typeof command === 'function') command(view);
              else {
                for (let name in command) {
                  const props = command[name]

                  if (typeof props === 'function') {
                    props(view); // not sure what, if anything, should be passed in here
                  }
                  else {
                    const element = view.select(name);

                    for (let propName in props) {
                      const action = props[propName],
                            propValue = element.get(propName);

                      if (typeof action === 'function') element.set(propName, action(propValue));
                      else {
                        const parameters = [];
                        let i = 0;
                        for (; i < action.length - 1; i++) parameters.push(element.get(action[i]));
                        element.set(propName, action[i](propValue, ...parameters));
                      }
                    }
                  }
                }
              }
            }

            function define(commands) {
              //may want to do something fancier here, perhaps there are things in `run` that could be pre-cached?
              return commands;
            }
          }
          // applyControls(controls);

          // function applyControls(controls) {
          //   window.onkeydown = event => {

          //   }
          // }

          // window.onkeydown = event => {
          //   const present = view.select('present'),
          //         index = present.get('index'),
          //         length = present.get('length');

          //   switch (event.keyCode) {
          //     case 37:
          //     case 38: commands['prevSlide'](); break;
          //     case 39:
          //     case 40: commands['nextSlide'](); break;
          //   }
          // }

          //   index: ['length', (index, length) => (length + index - 1) % length]

          // nextSlide: {
          //   index: ({length, index}) => (length + index - 1) % length
          // }
          // prevSlide: {
          //   index: ({length, index}) => (index + 1) % length;
          // }

          // present.set(name, fn(present))

          // function nextSlide(present) {
          //   present.set()
          // }
        </script>
      </mathbox>
      <div class="panel">
        <style>
          .box .panel {
            display: none;
            flex: 1;
          }

          .box.settings .panel {
            display: block;
          }
        </style>
      </div>
      <div class="settings" onclick="expandPanel(event, this)">S</div>
    </div>
  </body>
</html>
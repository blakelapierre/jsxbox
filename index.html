<html>
  <head>
    <title>mathbox/jsx</title>
  </head>
  <body>
    <script src="handler.js"></script>
    <script src="mathbox-bundle.js"></script>

    <style type="text/css">
    body {
      padding: 0;
      margin: 0;

      display: flex;
    }

    .mathbox-container {
      flex: 1 1 auto;
    }

    #text {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;

      text-align: center;

      font-size: 2em;
      font-weight: bold;

      text-shadow: 0px 0px 5px #fff;
    }

    .not-final {
      background-color: #ff0;
    }

    .alternatives {
      border: solid 2px #f00;
    }
    </style>

    <script type="mathbox/jsx">
      const fftSize = Math.pow(2, 5),
            history = 1200,
            pointSize = 1;

      const speechCapacity = 5;


      const settings = {
        int: {
          time: {
            fftSize,
            history,
            spread: 1,
            size: 2,
            shape: 'square',
            color: '#993333',
            opacity: 0.05
          },

          freq: {
            fftSize,
            history,
            spread: 1,
            size: 12,
            shape: 'square',
            // color: '#0000FF',
            color: t => freqPower * freqPower,
            opacity: 0.25
          }
        },

        float: {
          freq: {
            fftSize,
            history,
            spread: 1,
            shape: 'circle',
            color: '#FFFFFF',
            opacity: 0.75,
            size: 2
          }
        }
      };

      <root focus={3}>
        <camera proxy={true}
                position={[0, 0, 4]}
                lookAt={t => [0, 3 * Math.cos(t / 7), 0]}
                fov={40}
        />
        <cartesian
          rotation={t => [Math.cos(t / 5) * Math.PI / 13, -Math.sin(t / 23) * Math.PI / 2, 0]}
          position={t => [0, 3 * Math.cos(t / 7), 0]}
        >
          <polar
            position={[0, 0, 0]}
            range={[[-settings.int.time.fftSize / 2, settings.int.time.fftSize / 2], [-127, 127]]}
            bend={2 * Math.PI / settings.int.time.fftSize}
            scale={[16 / 9, 1, 2]}
          >
            <array
              length={settings.int.time.fftSize}
              channels={1}
              history={settings.int.time.history}
              expr={(emit, x, i, time) => emit(intTime[x])}
            />
            <transpose order='xw' />
            <swizzle order={"yxy"} />
            <spread
              width={[settings.int.time.fftSize, 0, 0, 0]}
              depth={[0, 0, settings.int.time.spread, 0]}
              height={[0, settings.int.time.fftsize, 0, 0]}
            />
            <point
              size={settings.int.time.size}
              shape={settings.int.time.shape}
              color={settings.int.time.color}
            />
          </polar>


          <polar
            position={[0, 0, 0]}
            range={t => [[-(intFreq || [0]).length / 2, (intFreq || [0]).length / 2], [(analyser || {}).minDecibels || 0, (analyser || {}).maxDecibels || 1]]}
            scale={[16 / 9, 2]}
          >
            <array
              length={settings.int.freq.fftSize / 2}
              channels={1}
              history={settings.int.freq.history}
              expr={(emit, x, i, time) => emit(intFreq[x])}
            />
            <transpose order="xw" />
            <swizzle order='yx' />
            <spread
              width={[settings.int.freq.fftSize, 0, 0, 0]}
              depth={[0, 0, settings.int.freq.spread, 0]}
            />
            <point
              size={settings.int.freq.size}
              color={settings.int.freq.color}
              opacity={settings.int.freq.opacity}
              blending={'add'}
            />
          </polar>

          <cartesian
            position={[0, 0, 0]}
            range={[[-fftSize / 2, fftSize / 2], [-1, 1]]}
            scale={[16 / 9, 2]}
          >
            <array
              length={fftSize}
              channels={1}
              history={1024}
              expr={(emit, x, i, time) => emit(floatTime[x])}
            />
            <transpose order="xw"/>
            <swizzle order="yx" />
            <spread width={[fftSize, 0, 0, 0]} depth={[0, 0, 1, 0]} />
            <point
              size={pointSize}
              color="#00FF00"
              blending={'add'}
              opacity={0.25}
            />
          </cartesian>

          <cartesian
            position={[0, 0, 0]}
            range={[[-settings.float.freq.fftSize / 2, settings.float.freq.fftSize / 2], [-196, 0], [-1, 1]]}
            scale={[16 / 9, 1]}
          >
            <array
              length={settings.float.freq.fftSize / 2}
              channels={1}
              expr={(emit, x, i, time) => emit(floatFreq[x])}
              history={settings.float.freq.history}
            />
            <transpose order="xw" />
            <swizzle order={"yx"} />
            <spread width={[settings.float.freq.fftSize, 0, 0, 0]} depth={[0, 0, settings.float.freq.spread, 0]} />
            <point size={settings.float.freq.size} color={settings.float.freq.color} blending={'normal'} opacity={settings.float.freq.opacity} shape={settings.float.freq.shape} />
          </cartesian>
        </cartesian>
      </root>

      let analyser;
      let floatTime, floatFreq, intTime, intFreq, timePower, freqPower;

      const context = new (window.AudioContext || window.webkitAudioContext)();

      navigator.getUserMedia = navigator.getUserMedia
                            || navigator.webkitGetUserMedia
                            || navigator.mozGetUserMedia
                            || navigator.msGetUserMedia;

      // navigator.getUserMedia({audio: true}, stream, error);
      navigator.getUserMedia({audio: true}, stream => analyser = createAnalyser(stream), error);

      recognizeSpeech(window.webkitSpeechRecognition);

      function createAnalyser(stream) {
        const input = context.createMediaStreamSource(stream),
              analyser = context.createAnalyser();

        input.connect(analyser);

        return setAnalyser(analyser);
      }

      function error(error) {
        console.log(error);
      }

      function setAnalyser(analyser) {
        console.dir(analyser);
        analyser.fftSize = fftSize;

        floatTime = new Float32Array(analyser.fftSize);
        floatFreq = new Float32Array(analyser.frequencyBinCount);
        intTime = new Uint8Array(analyser.fftSize);
        intFreq = new Uint8Array(analyser.frequencyBinCount);

        console.log({analyser});

        update();

        return analyser;

        function update() {
          requestAnimationFrame(update);

          analyser.getFloatTimeDomainData(floatTime);
          analyser.getFloatFrequencyData(floatFreq);

          analyser.getByteTimeDomainData(intTime);
          analyser.getByteFrequencyData(intFreq);

          timePower = power(intTime);
          freqPower = power(intFreq);

          // three.renderer.setClearColor(freqPower);

          function power(array) {
            const {length} = array;

            let sum = 0;

            for (let i = 0; i < length; i++) sum += array[i] * array[i];

            return sum / length;
          }
        }
      }

      console.log(mathbox);

      const text = document.getElementById('text');

      let speech = [],
          nextIndex = 0;
      function recognizeSpeech(SpeechRecognition) {
        const sr = new SpeechRecognition();

        sr.continuous = true;
        sr.interimResults = true;
        sr.lang = 'en-US';

        sr.onstart = () => console.log('start');
        sr.onresult = gotResult;
        sr.onerror = event => console.dir(event);
        sr.onend = () => setTimeout(() => sr.start(), 1000);

        sr.onspeechstart = event => console.log('speech start', event);
        sr.onspeechend = event => console.log('speech end', event);

        sr.onsoundstart = event => console.log('sound start', event);
        sr.onsoundend = event => console.log('sound end', event);

        sr.start();

        function gotResult(event) {
          const {results, resultIndex, timeStamp} = event,
                {length} = results;

          console.log('Got results', {results});

          if (results) {
            text.innerHTML = map(results, createResult).join('<br>');

            // const r = new Date(timeStamp).toString() + printResult(results[resultIndex]);

            // let alt = speech[nextIndex] = r;
            // nextIndex = (nextIndex + 1) % speechCapacity;
          }

          function createResult(result) {
            var alternatives = map(result, alternative => createAlternative(alternative, result.isFinal));

            if (alternatives.length > 1) return `<span class="alternatives">${alternatives.join('')}</span>`;
            return `${alternatives.join('')}`;
          }

          function createAlternative(alternative, isFinal) {
            return `<span class="${isFinal ? 'final' : 'not-final'}">${alternative.transcript}</span>`;
          }
        }
      }

      function getSpeech(x) {
        return speech[x] || `speech ${x}`;
      }

      function map(arraylike, fn) {
        return Array.prototype.map.call(arraylike, fn);
      }

    </script>
    <div id="text"></div>
  </body>
</html>
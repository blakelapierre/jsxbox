<html>
  <head>
    <title>mathbox/jsx</title>

    <script>less = {async: true}; //wot</script>

    <style type="text/less">
    body {
      margin: 0;
      padding: 0;

      display: flex;

      overflow: hidden;
    }

    mathbox {
      display: flex;

      flex: 1 1 auto;

      mathbox-container {
        width: 50%;
      }

      panel {
        flex: 1 1 auto;

        min-width: 50%;

        display: flex;
        flex-direction: column;

        overflow: auto;

        &.after {
          order: 1;
        }

        textarea {
          flex: 1 1 auto;

          background: #000;

          border: none;

          color: #fff;

          white-space: pre-wrap;
          font-family: monospace;

          overflow: visible;

          cursor: text;

          transition: all 0.25s ease-in-out;
        }

        update-notifier {
          display: none;

          flex: 0 0 auto;

          width: 100%;

          overflow: auto;

          background-color: #cc6666;

          transition: all 0.25s ease-in-out;
        }

        &.has-error {
          update-notifier {
            display: block;

            white-space: pre-wrap;
            font-family: monospace;
          }
        }
      }
    }
    </style>
  </head>
  <body>
    <script src="dist/handler.js"></script>
    <script src="lib/mathbox-bundle.js"></script>

    <mathbox tabindex="2">
      <script type="mathbox/jsx">
      const {data, domain, range} = generateData(1, 1, 2, 256, 256, 10, uniformRandom(0.005)); // might still work on some phones, there should be a way to optimize this, but the strict limit on the length of `data` is due to webgl/your_gpu

      <root>
          <camera
            proxy={true}
            lookAt={[-5, 0, 5, 0]}
            position={t=>[0, 0, 1 + (Math.cos(t / 4) + 1) * 5]}
            fov={100}
          />

          <spherical
            range={[[range.min_x, range.max_x], [range.min_y, range.max_y], [range.min_z, range.max_z], [-1, 1]]}
            scale={[16/9, 2, 2, 1]}
            position={[-5, 0, 5, 0]}
            bend={t=> (Math.sin(t / 5) + 1) / 25}
            rotation={t => [t / 3, -t / 7, t / 5]}
          >
            <array length={data.length} channels={4} data={data} />
            <swizzle order={'xyzw'} />
            <point size={5} color={[64 / 255, 128 / 255, 192 / 255]} blending={'add'} shape={'square'}/>
          </spherical>

      </root>

      function generateData(x_min, y_min, z_min, width, height, depth, selector = divisors, transform = scaledWFrom3Items) {
        const x_max = x_min + width - 1,
              y_max = y_min + height - 1,
              z_max = z_min + depth - 1,
              data = [];

        let min_x = Number.MAX_VALUE, max_x = Number.MIN_VALUE,
            min_y = Number.MAX_VALUE, max_y = Number.MIN_VALUE,
            min_z = Number.MAX_VALUE, max_z = Number.MIN_VALUE;

        for (let x = x_min; x < x_max; x++)
          for (let y = y_min; y < y_max; y++)
            for (let z = z_min; z < z_max; z++)
              if (selector(x, y, z)) {
                const transformed = transform(x, y, z),
                      [tx, ty, tz, tw] = transformed;

                if (tx < min_x) min_x = tx;
                if (tx > max_x) max_x = tx;

                if (ty < min_y) min_y = ty;
                if (ty > max_y) max_y = ty;

                if (tz < min_z) min_z = tz;
                if (tz > max_z) max_z = tz;

                data.push(transformed);
              }

        return {
          data,
          domain: {x_min, y_min, z_min, x_max, y_max, z_max, width, height, depth},
          range: {min_x, min_y, min_z, max_x, max_y, max_z}
        };
      }

      function uniformRandom(p) {
        return (x, y, z) => Math.random() < p;
      }

      function divisors(x, y, z) {
        return x !== 0 && y !== 0 && x % y === z;
      }

      function scaledWFrom3Items(x, y, z) {
        return [x, y, z, 1 + x / y * z];
      }

      module.exports = {
        controls: [
          [['D'], 'debugmessage'],
          [['F'], 'fovchange']
        ],
        commands: {
          'debugmessage': () => console.log('it worked'),
          'fovchange': {'camera': {fov: nextFov}}

          // 'fovchange': ['camera', {fov: nextFov}] // Should this be allowed?

          // Alternatives

          // Apply changes from last value
          // 'fovchange': {camera: {fov: fov => fov - 10}}

          // Use other properties
          // 'fovchange': {camera: {fov: ['position', (fov, position) => fov + position.z * 5]}}

          // Use constants
          // 'fovchange': {camera: {fov: 10}}

          // Don't need to request other properties to use array syntax
          // 'fovchange': {camera: {fov: [nextFov]}}
        },
        editorPanel: true
      };

      let index = 0;
      const fovs = [30, 60, 90, 120];
      function nextFov() {
        console.log('next', fovs, index);
        const thisFov = fovs[index];
        index = (index + 1 ) % fovs.length;
        return thisFov;
      }

      </script>
    </mathbox>
  </body>
</html>